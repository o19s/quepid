// @codemirror/state@6.5.4 downloaded from https://ga.jspm.io/npm:@codemirror/state@6.5.4/dist/index.js

import{findClusterBreak as t}from"@marijn/find-cluster-break";class Text{lineAt(t){if(t<0||t>this.length)throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);return this.lineInner(t,false,1,0)}line(t){if(t<1||t>this.lines)throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);return this.lineInner(t,true,1,0)}replace(t,e,n){[t,e]=s(this,t,e);let i=[];this.decompose(0,t,i,2);n.length&&n.decompose(0,n.length,i,3);this.decompose(e,this.length,i,1);return TextNode.from(i,this.length-(e-t)+n.length)}append(t){return this.replace(this.length,this.length,t)}slice(t,e=this.length){[t,e]=s(this,t,e);let n=[];this.decompose(t,e,n,0);return TextNode.from(n,e-t)}eq(t){if(t==this)return true;if(t.length!=this.length||t.lines!=this.lines)return false;let e=this.scanIdentical(t,1),n=this.length-this.scanIdentical(t,-1);let i=new RawTextCursor(this),s=new RawTextCursor(t);for(let t=e,r=e;;){i.next(t);s.next(t);t=0;if(i.lineBreak!=s.lineBreak||i.done!=s.done||i.value!=s.value)return false;r+=i.value.length;if(i.done||r>=n)return true}}iter(t=1){return new RawTextCursor(this,t)}iterRange(t,e=this.length){return new PartialTextCursor(this,t,e)}iterLines(t,e){let n;if(t==null)n=this.iter();else{e==null&&(e=this.lines+1);let i=this.line(t).from;n=this.iterRange(i,Math.max(i,e==this.lines+1?this.length:e<=1?0:this.line(e-1).to))}return new LineCursor(n)}toString(){return this.sliceString(0)}toJSON(){let t=[];this.flatten(t);return t}constructor(){}static of(t){if(t.length==0)throw new RangeError("A document must have at least one line");return t.length!=1||t[0]?t.length<=32?new TextLeaf(t):TextNode.from(TextLeaf.split(t,[])):Text.empty}}class TextLeaf extends Text{constructor(t,n=e(t)){super();this.text=t;this.length=n}get lines(){return this.text.length}get children(){return null}lineInner(t,e,n,i){for(let s=0;;s++){let r=this.text[s],o=i+r.length;if((e?n:o)>=t)return new Line(i,o,n,r);i=o+1;n++}}decompose(t,e,s,r){let o=t<=0&&e>=this.length?this:new TextLeaf(i(this.text,t,e),Math.min(e,this.length)-Math.max(0,t));if(r&1){let t=s.pop();let e=n(o.text,t.text.slice(),0,o.length);if(e.length<=32)s.push(new TextLeaf(e,t.length+o.length));else{let t=e.length>>1;s.push(new TextLeaf(e.slice(0,t)),new TextLeaf(e.slice(t)))}}else s.push(o)}replace(t,e,r){if(!(r instanceof TextLeaf))return super.replace(t,e,r);[t,e]=s(this,t,e);let o=n(this.text,n(r.text,i(this.text,0,t)),e);let a=this.length+r.length-(e-t);return o.length<=32?new TextLeaf(o,a):TextNode.from(TextLeaf.split(o,[]),a)}sliceString(t,e=this.length,n="\n"){[t,e]=s(this,t,e);let i="";for(let s=0,r=0;s<=e&&r<this.text.length;r++){let o=this.text[r],a=s+o.length;s>t&&r&&(i+=n);t<a&&e>s&&(i+=o.slice(Math.max(0,t-s),e-s));s=a+1}return i}flatten(t){for(let e of this.text)t.push(e)}scanIdentical(){return 0}static split(t,e){let n=[],i=-1;for(let s of t){n.push(s);i+=s.length+1;if(n.length==32){e.push(new TextLeaf(n,i));n=[];i=-1}}i>-1&&e.push(new TextLeaf(n,i));return e}}class TextNode extends Text{constructor(t,e){super();this.children=t;this.length=e;this.lines=0;for(let e of t)this.lines+=e.lines}lineInner(t,e,n,i){for(let s=0;;s++){let r=this.children[s],o=i+r.length,a=n+r.lines-1;if((e?a:o)>=t)return r.lineInner(t,e,n,i);i=o+1;n=a+1}}decompose(t,e,n,i){for(let s=0,r=0;r<=e&&s<this.children.length;s++){let o=this.children[s],a=r+o.length;if(t<=a&&e>=r){let s=i&((r<=t?1:0)|(a>=e?2:0));r>=t&&a<=e&&!s?n.push(o):o.decompose(t-r,e-r,n,s)}r=a+1}}replace(t,e,n){[t,e]=s(this,t,e);if(n.lines<this.lines)for(let i=0,s=0;i<this.children.length;i++){let r=this.children[i],o=s+r.length;if(t>=s&&e<=o){let a=r.replace(t-s,e-s,n);let h=this.lines-r.lines+a.lines;if(a.lines<h>>4&&a.lines>h>>6){let s=this.children.slice();s[i]=a;return new TextNode(s,this.length-(e-t)+n.length)}return super.replace(s,o,a)}s=o+1}return super.replace(t,e,n)}sliceString(t,e=this.length,n="\n"){[t,e]=s(this,t,e);let i="";for(let s=0,r=0;s<this.children.length&&r<=e;s++){let o=this.children[s],a=r+o.length;r>t&&s&&(i+=n);t<a&&e>r&&(i+=o.sliceString(t-r,e-r,n));r=a+1}return i}flatten(t){for(let e of this.children)e.flatten(t)}scanIdentical(t,e){if(!(t instanceof TextNode))return 0;let n=0;let[i,s,r,o]=e>0?[0,0,this.children.length,t.children.length]:[this.children.length-1,t.children.length-1,-1,-1];for(;;i+=e,s+=e){if(i==r||s==o)return n;let a=this.children[i],h=t.children[s];if(a!=h)return n+a.scanIdentical(h,e);n+=a.length+1}}static from(t,e=t.reduce(((t,e)=>t+e.length+1),-1)){let n=0;for(let e of t)n+=e.lines;if(n<32){let n=[];for(let e of t)e.flatten(n);return new TextLeaf(n,e)}let i=Math.max(32,n>>5),s=i<<1,r=i>>1;let o=[],a=0,h=-1,l=[];function c(t){let e;if(t.lines>s&&t instanceof TextNode)for(let e of t.children)c(e);else if(t.lines>r&&(a>r||!a)){f();o.push(t)}else if(t instanceof TextLeaf&&a&&(e=l[l.length-1])instanceof TextLeaf&&t.lines+e.lines<=32){a+=t.lines;h+=t.length+1;l[l.length-1]=new TextLeaf(e.text.concat(t.text),e.length+1+t.length)}else{a+t.lines>i&&f();a+=t.lines;h+=t.length+1;l.push(t)}}function f(){if(a!=0){o.push(l.length==1?l[0]:TextNode.from(l,h));h=-1;a=l.length=0}}for(let e of t)c(e);f();return o.length==1?o[0]:new TextNode(o,e)}}Text.empty=new TextLeaf([""],0);function e(t){let e=-1;for(let n of t)e+=n.length+1;return e}function n(t,e,n=0,i=1e9){for(let s=0,r=0,o=true;r<t.length&&s<=i;r++){let a=t[r],h=s+a.length;if(h>=n){h>i&&(a=a.slice(0,i-s));s<n&&(a=a.slice(n-s));if(o){e[e.length-1]+=a;o=false}else e.push(a)}s=h+1}return e}function i(t,e,i){return n(t,[""],e,i)}class RawTextCursor{constructor(t,e=1){this.dir=e;this.done=false;this.lineBreak=false;this.value="";this.nodes=[t];this.offsets=[e>0?1:(t instanceof TextLeaf?t.text.length:t.children.length)<<1]}nextInner(t,e){this.done=this.lineBreak=false;for(;;){let n=this.nodes.length-1;let i=this.nodes[n],s=this.offsets[n],r=s>>1;let o=i instanceof TextLeaf?i.text.length:i.children.length;if(r==(e>0?o:0)){if(n==0){this.done=true;this.value="";return this}e>0&&this.offsets[n-1]++;this.nodes.pop();this.offsets.pop()}else if((s&1)==(e>0?0:1)){this.offsets[n]+=e;if(t==0){this.lineBreak=true;this.value="\n";return this}t--}else if(i instanceof TextLeaf){let s=i.text[r+(e<0?-1:0)];this.offsets[n]+=e;if(s.length>Math.max(0,t)){this.value=t==0?s:e>0?s.slice(t):s.slice(0,s.length-t);return this}t-=s.length}else{let s=i.children[r+(e<0?-1:0)];if(t>s.length){t-=s.length;this.offsets[n]+=e}else{e<0&&this.offsets[n]--;this.nodes.push(s);this.offsets.push(e>0?1:(s instanceof TextLeaf?s.text.length:s.children.length)<<1)}}}}next(t=0){if(t<0){this.nextInner(-t,-this.dir);t=this.value.length}return this.nextInner(t,this.dir)}}class PartialTextCursor{constructor(t,e,n){this.value="";this.done=false;this.cursor=new RawTextCursor(t,e>n?-1:1);this.pos=e>n?t.length:0;this.from=Math.min(e,n);this.to=Math.max(e,n)}nextInner(t,e){if(e<0?this.pos<=this.from:this.pos>=this.to){this.value="";this.done=true;return this}t+=Math.max(0,e<0?this.pos-this.to:this.from-this.pos);let n=e<0?this.pos-this.from:this.to-this.pos;t>n&&(t=n);n-=t;let{value:i}=this.cursor.next(t);this.pos+=(i.length+t)*e;this.value=i.length<=n?i:e<0?i.slice(i.length-n):i.slice(0,n);this.done=!this.value;return this}next(t=0){t<0?t=Math.max(t,this.from-this.pos):t>0&&(t=Math.min(t,this.to-this.pos));return this.nextInner(t,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&this.value!=""}}class LineCursor{constructor(t){this.inner=t;this.afterBreak=true;this.value="";this.done=false}next(t=0){let{done:e,lineBreak:n,value:i}=this.inner.next(t);if(e&&this.afterBreak){this.value="";this.afterBreak=false}else if(e){this.done=true;this.value=""}else if(n)if(this.afterBreak)this.value="";else{this.afterBreak=true;this.next()}else{this.value=i;this.afterBreak=false}return this}get lineBreak(){return false}}if(typeof Symbol!="undefined"){Text.prototype[Symbol.iterator]=function(){return this.iter()};RawTextCursor.prototype[Symbol.iterator]=PartialTextCursor.prototype[Symbol.iterator]=LineCursor.prototype[Symbol.iterator]=function(){return this}}class Line{constructor(t,e,n,i){this.from=t;this.to=e;this.number=n;this.text=i}get length(){return this.to-this.from}}function s(t,e,n){e=Math.max(0,Math.min(t.length,e));return[e,Math.max(e,Math.min(t.length,n))]}function r(e,n,i=true,s=true){return t(e,n,i,s)}function o(t){return t>=56320&&t<57344}function a(t){return t>=55296&&t<56320}function h(t,e){let n=t.charCodeAt(e);if(!a(n)||e+1==t.length)return n;let i=t.charCodeAt(e+1);return o(i)?i-56320+(n-55296<<10)+65536:n}function l(t){if(t<=65535)return String.fromCharCode(t);t-=65536;return String.fromCharCode(55296+(t>>10),56320+(t&1023))}function c(t){return t<65536?1:2}const f=/\r\n?|\n/;var u=function(t){t[t.Simple=0]="Simple";t[t.TrackDel=1]="TrackDel";t[t.TrackBefore=2]="TrackBefore";t[t.TrackAfter=3]="TrackAfter";return t}(u||(u={}));class ChangeDesc{constructor(t){this.sections=t}get length(){let t=0;for(let e=0;e<this.sections.length;e+=2)t+=this.sections[e];return t}get newLength(){let t=0;for(let e=0;e<this.sections.length;e+=2){let n=this.sections[e+1];t+=n<0?this.sections[e]:n}return t}get empty(){return this.sections.length==0||this.sections.length==2&&this.sections[1]<0}iterGaps(t){for(let e=0,n=0,i=0;e<this.sections.length;){let s=this.sections[e++],r=this.sections[e++];if(r<0){t(n,i,s);i+=s}else i+=r;n+=s}}iterChangedRanges(t,e=false){p(this,t,e)}get invertedDesc(){let t=[];for(let e=0;e<this.sections.length;){let n=this.sections[e++],i=this.sections[e++];i<0?t.push(n,i):t.push(i,n)}return new ChangeDesc(t)}composeDesc(t){return this.empty?t:t.empty?this:S(this,t)}mapDesc(t,e=false){return t.empty?this:m(this,t,e)}mapPos(t,e=-1,n=u.Simple){let i=0,s=0;for(let r=0;r<this.sections.length;){let o=this.sections[r++],a=this.sections[r++],h=i+o;if(a<0){if(h>t)return s+(t-i);s+=o}else{if(n!=u.Simple&&h>=t&&(n==u.TrackDel&&i<t&&h>t||n==u.TrackBefore&&i<t||n==u.TrackAfter&&h>t))return null;if(h>t||h==t&&e<0&&!o)return t==i||e<0?s:s+a;s+=a}i=h}if(t>i)throw new RangeError(`Position ${t} is out of range for changeset of length ${i}`);return s}touchesRange(t,e=t){for(let n=0,i=0;n<this.sections.length&&i<=e;){let s=this.sections[n++],r=this.sections[n++],o=i+s;if(r>=0&&i<=e&&o>=t)return!(i<t&&o>e)||"cover";i=o}return false}toString(){let t="";for(let e=0;e<this.sections.length;){let n=this.sections[e++],i=this.sections[e++];t+=(t?" ":"")+n+(i>=0?":"+i:"")}return t}toJSON(){return this.sections}static fromJSON(t){if(!Array.isArray(t)||t.length%2||t.some((t=>typeof t!="number")))throw new RangeError("Invalid JSON representation of ChangeDesc");return new ChangeDesc(t)}static create(t){return new ChangeDesc(t)}}class ChangeSet extends ChangeDesc{constructor(t,e){super(t);this.inserted=e}apply(t){if(this.length!=t.length)throw new RangeError("Applying change set to a document with the wrong length");p(this,((e,n,i,s,r)=>t=t.replace(i,i+(n-e),r)),false);return t}mapDesc(t,e=false){return m(this,t,e,true)}invert(t){let e=this.sections.slice(),n=[];for(let i=0,s=0;i<e.length;i+=2){let r=e[i],o=e[i+1];if(o>=0){e[i]=o;e[i+1]=r;let a=i>>1;while(n.length<a)n.push(Text.empty);n.push(r?t.slice(s,s+r):Text.empty)}s+=r}return new ChangeSet(e,n)}compose(t){return this.empty?t:t.empty?this:S(this,t,true)}map(t,e=false){return t.empty?this:m(this,t,e,true)}iterChanges(t,e=false){p(this,t,e)}get desc(){return ChangeDesc.create(this.sections)}filter(t){let e=[],n=[],i=[];let s=new SectionIter(this);t:for(let r=0,o=0;;){let a=r==t.length?1e9:t[r++];while(o<a||o==a&&s.len==0){if(s.done)break t;let t=Math.min(s.len,a-o);g(i,t,-1);let r=s.ins==-1?-1:s.off==0?s.ins:0;g(e,t,r);r>0&&d(n,e,s.text);s.forward(t);o+=t}let h=t[r++];while(o<h){if(s.done)break t;let t=Math.min(s.len,h-o);g(e,t,-1);g(i,t,s.ins==-1?-1:s.off==0?s.ins:0);s.forward(t);o+=t}}return{changes:new ChangeSet(e,n),filtered:ChangeDesc.create(i)}}toJSON(){let t=[];for(let e=0;e<this.sections.length;e+=2){let n=this.sections[e],i=this.sections[e+1];i<0?t.push(n):i==0?t.push([n]):t.push([n].concat(this.inserted[e>>1].toJSON()))}return t}static of(t,e,n){let i=[],s=[],r=0;let o=null;function a(t=false){if(!t&&!i.length)return;r<e&&g(i,e-r,-1);let n=new ChangeSet(i,s);o=o?o.compose(n.map(o)):n;i=[];s=[];r=0}function h(t){if(Array.isArray(t))for(let e of t)h(e);else if(t instanceof ChangeSet){if(t.length!=e)throw new RangeError(`Mismatched change set length (got ${t.length}, expected ${e})`);a();o=o?o.compose(t.map(o)):t}else{let{from:o,to:h=o,insert:l}=t;if(o>h||o<0||h>e)throw new RangeError(`Invalid change range ${o} to ${h} (in doc of length ${e})`);let c=l?typeof l=="string"?Text.of(l.split(n||f)):l:Text.empty;let u=c.length;if(o==h&&u==0)return;o<r&&a();o>r&&g(i,o-r,-1);g(i,h-o,u);d(s,i,c);r=h}}h(t);a(!o);return o}static empty(t){return new ChangeSet(t?[t,-1]:[],[])}static fromJSON(t){if(!Array.isArray(t))throw new RangeError("Invalid JSON representation of ChangeSet");let e=[],n=[];for(let i=0;i<t.length;i++){let s=t[i];if(typeof s=="number")e.push(s,-1);else{if(!Array.isArray(s)||typeof s[0]!="number"||s.some(((t,e)=>e&&typeof t!="string")))throw new RangeError("Invalid JSON representation of ChangeSet");if(s.length==1)e.push(s[0],0);else{while(n.length<i)n.push(Text.empty);n[i]=Text.of(s.slice(1));e.push(s[0],n[i].length)}}}return new ChangeSet(e,n)}static createSet(t,e){return new ChangeSet(t,e)}}function g(t,e,n,i=false){if(e==0&&n<=0)return;let s=t.length-2;if(s>=0&&n<=0&&n==t[s+1])t[s]+=e;else if(s>=0&&e==0&&t[s]==0)t[s+1]+=n;else if(i){t[s]+=e;t[s+1]+=n}else t.push(e,n)}function d(t,e,n){if(n.length==0)return;let i=e.length-2>>1;if(i<t.length)t[t.length-1]=t[t.length-1].append(n);else{while(t.length<i)t.push(Text.empty);t.push(n)}}function p(t,e,n){let i=t.inserted;for(let s=0,r=0,o=0;o<t.sections.length;){let a=t.sections[o++],h=t.sections[o++];if(h<0){s+=a;r+=a}else{let l=s,c=r,f=Text.empty;for(;;){l+=a;c+=h;h&&i&&(f=f.append(i[o-2>>1]));if(n||o==t.sections.length||t.sections[o+1]<0)break;a=t.sections[o++];h=t.sections[o++]}e(s,l,r,c,f);s=l;r=c}}}function m(t,e,n,i=false){let s=[],r=i?[]:null;let o=new SectionIter(t),a=new SectionIter(e);for(let t=-1;;){if(o.done&&a.len||a.done&&o.len)throw new Error("Mismatched change set lengths");if(o.ins==-1&&a.ins==-1){let t=Math.min(o.len,a.len);g(s,t,-1);o.forward(t);a.forward(t)}else if(a.ins>=0&&(o.ins<0||t==o.i||o.off==0&&(a.len<o.len||a.len==o.len&&!n))){let e=a.len;g(s,a.ins,-1);while(e){let n=Math.min(o.len,e);if(o.ins>=0&&t<o.i&&o.len<=n){g(s,0,o.ins);r&&d(r,s,o.text);t=o.i}o.forward(n);e-=n}a.next()}else{if(!(o.ins>=0)){if(o.done&&a.done)return r?ChangeSet.createSet(s,r):ChangeDesc.create(s);throw new Error("Mismatched change set lengths")}{let e=0,n=o.len;while(n)if(a.ins==-1){let t=Math.min(n,a.len);e+=t;n-=t;a.forward(t)}else{if(!(a.ins==0&&a.len<n))break;n-=a.len;a.next()}g(s,e,t<o.i?o.ins:0);r&&t<o.i&&d(r,s,o.text);t=o.i;o.forward(o.len-n)}}}}function S(t,e,n=false){let i=[];let s=n?[]:null;let r=new SectionIter(t),o=new SectionIter(e);for(let t=false;;){if(r.done&&o.done)return s?ChangeSet.createSet(i,s):ChangeDesc.create(i);if(r.ins==0){g(i,r.len,0,t);r.next()}else if(o.len!=0||o.done){if(r.done||o.done)throw new Error("Mismatched change set lengths");{let e=Math.min(r.len2,o.len),n=i.length;if(r.ins==-1){let n=o.ins==-1?-1:o.off?0:o.ins;g(i,e,n,t);s&&n&&d(s,i,o.text)}else if(o.ins==-1){g(i,r.off?0:r.len,e,t);s&&d(s,i,r.textBit(e))}else{g(i,r.off?0:r.len,o.off?0:o.ins,t);s&&!o.off&&d(s,i,o.text)}t=(r.ins>e||o.ins>=0&&o.len>e)&&(t||i.length>n);r.forward2(e);o.forward(e)}}else{g(i,0,o.ins,t);s&&d(s,i,o.text);o.next()}}}class SectionIter{constructor(t){this.set=t;this.i=0;this.next()}next(){let{sections:t}=this.set;if(this.i<t.length){this.len=t[this.i++];this.ins=t[this.i++]}else{this.len=0;this.ins=-2}this.off=0}get done(){return this.ins==-2}get len2(){return this.ins<0?this.len:this.ins}get text(){let{inserted:t}=this.set,e=this.i-2>>1;return e>=t.length?Text.empty:t[e]}textBit(t){let{inserted:e}=this.set,n=this.i-2>>1;return n>=e.length&&!t?Text.empty:e[n].slice(this.off,t==null?void 0:this.off+t)}forward(t){if(t==this.len)this.next();else{this.len-=t;this.off+=t}}forward2(t){if(this.ins==-1)this.forward(t);else if(t==this.ins)this.next();else{this.ins-=t;this.off+=t}}}class SelectionRange{constructor(t,e,n){this.from=t;this.to=e;this.flags=n}get anchor(){return this.flags&32?this.to:this.from}get head(){return this.flags&32?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return this.flags&8?-1:this.flags&16?1:0}get bidiLevel(){let t=this.flags&7;return t==7?null:t}get goalColumn(){let t=this.flags>>6;return t==16777215?void 0:t}map(t,e=-1){let n,i;if(this.empty)n=i=t.mapPos(this.from,e);else{n=t.mapPos(this.from,1);i=t.mapPos(this.to,-1)}return n==this.from&&i==this.to?this:new SelectionRange(n,i,this.flags)}extend(t,e=t){if(t<=this.anchor&&e>=this.anchor)return EditorSelection.range(t,e);let n=Math.abs(t-this.anchor)>Math.abs(e-this.anchor)?t:e;return EditorSelection.range(this.anchor,n)}eq(t,e=false){return this.anchor==t.anchor&&this.head==t.head&&this.goalColumn==t.goalColumn&&(!e||!this.empty||this.assoc==t.assoc)}toJSON(){return{anchor:this.anchor,head:this.head}}static fromJSON(t){if(!t||typeof t.anchor!="number"||typeof t.head!="number")throw new RangeError("Invalid JSON representation for SelectionRange");return EditorSelection.range(t.anchor,t.head)}static create(t,e,n){return new SelectionRange(t,e,n)}}class EditorSelection{constructor(t,e){this.ranges=t;this.mainIndex=e}map(t,e=-1){return t.empty?this:EditorSelection.create(this.ranges.map((n=>n.map(t,e))),this.mainIndex)}eq(t,e=false){if(this.ranges.length!=t.ranges.length||this.mainIndex!=t.mainIndex)return false;for(let n=0;n<this.ranges.length;n++)if(!this.ranges[n].eq(t.ranges[n],e))return false;return true}get main(){return this.ranges[this.mainIndex]}asSingle(){return this.ranges.length==1?this:new EditorSelection([this.main],0)}addRange(t,e=true){return EditorSelection.create([t].concat(this.ranges),e?0:this.mainIndex+1)}replaceRange(t,e=this.mainIndex){let n=this.ranges.slice();n[e]=t;return EditorSelection.create(n,this.mainIndex)}toJSON(){return{ranges:this.ranges.map((t=>t.toJSON())),main:this.mainIndex}}static fromJSON(t){if(!t||!Array.isArray(t.ranges)||typeof t.main!="number"||t.main>=t.ranges.length)throw new RangeError("Invalid JSON representation for EditorSelection");return new EditorSelection(t.ranges.map((t=>SelectionRange.fromJSON(t))),t.main)}static single(t,e=t){return new EditorSelection([EditorSelection.range(t,e)],0)}static create(t,e=0){if(t.length==0)throw new RangeError("A selection needs at least one range");for(let n=0,i=0;i<t.length;i++){let s=t[i];if(s.empty?s.from<=n:s.from<n)return EditorSelection.normalized(t.slice(),e);n=s.to}return new EditorSelection(t,e)}static cursor(t,e=0,n,i){return SelectionRange.create(t,t,(e==0?0:e<0?8:16)|(n==null?7:Math.min(6,n))|(i!==null&&i!==void 0?i:16777215)<<6)}static range(t,e,n,i){let s=(n!==null&&n!==void 0?n:16777215)<<6|(i==null?7:Math.min(6,i));return e<t?SelectionRange.create(e,t,48|s):SelectionRange.create(t,e,(e>t?8:0)|s)}static normalized(t,e=0){let n=t[e];t.sort(((t,e)=>t.from-e.from));e=t.indexOf(n);for(let n=1;n<t.length;n++){let i=t[n],s=t[n-1];if(i.empty?i.from<=s.to:i.from<s.to){let r=s.from,o=Math.max(i.to,s.to);n<=e&&e--;t.splice(--n,2,i.anchor>i.head?EditorSelection.range(o,r):EditorSelection.range(r,o))}}return new EditorSelection(t,e)}}function x(t,e){for(let n of t.ranges)if(n.to>e)throw new RangeError("Selection points outside of document")}let v=0;class Facet{constructor(t,e,n,i,s){this.combine=t;this.compareInput=e;this.compare=n;this.isStatic=i;this.id=v++;this.default=t([]);this.extensions=typeof s=="function"?s(this):s}get reader(){return this}static define(t={}){return new Facet(t.combine||(t=>t),t.compareInput||((t,e)=>t===e),t.compare||(t.combine?(t,e)=>t===e:w),!!t.static,t.enables)}of(t){return new FacetProvider([],this,0,t)}compute(t,e){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(t,this,1,e)}computeN(t,e){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(t,this,2,e)}from(t,e){e||(e=t=>t);return this.compute([t],(n=>e(n.field(t))))}}function w(t,e){return t==e||t.length==e.length&&t.every(((t,n)=>t===e[n]))}class FacetProvider{constructor(t,e,n,i){this.dependencies=t;this.facet=e;this.type=n;this.value=i;this.id=v++}dynamicSlot(t){var e;let n=this.value;let i=this.facet.compareInput;let s=this.id,r=t[s]>>1,o=this.type==2;let a=false,h=false,l=[];for(let n of this.dependencies)n=="doc"?a=true:n=="selection"?h=true:(((e=t[n.id])!==null&&e!==void 0?e:1)&1)==0&&l.push(t[n.id]);return{create(t){t.values[r]=n(t);return 1},update(t,e){if(a&&e.docChanged||h&&(e.docChanged||e.selection)||k(t,l)){let e=n(t);if(o?!y(e,t.values[r],i):!i(e,t.values[r])){t.values[r]=e;return 1}}return 0},reconfigure:(t,e)=>{let a,h=e.config.address[s];if(h!=null){let s=A(e,h);if(this.dependencies.every((n=>n instanceof Facet?e.facet(n)===t.facet(n):!(n instanceof StateField)||e.field(n,false)==t.field(n,false)))||(o?y(a=n(t),s,i):i(a=n(t),s))){t.values[r]=s;return 0}}else a=n(t);t.values[r]=a;return 1}}}}function y(t,e,n){if(t.length!=e.length)return false;for(let i=0;i<t.length;i++)if(!n(t[i],e[i]))return false;return true}function k(t,e){let n=false;for(let i of e)b(t,i)&1&&(n=true);return n}function E(t,e,n){let i=n.map((e=>t[e.id]));let s=n.map((t=>t.type));let r=i.filter((t=>!(t&1)));let o=t[e.id]>>1;function a(t){let n=[];for(let e=0;e<i.length;e++){let r=A(t,i[e]);if(s[e]==2)for(let t of r)n.push(t);else n.push(r)}return e.combine(n)}return{create(t){for(let e of i)b(t,e);t.values[o]=a(t);return 1},update(t,n){if(!k(t,r))return 0;let i=a(t);if(e.compare(i,t.values[o]))return 0;t.values[o]=i;return 1},reconfigure(t,s){let r=k(t,i);let h=s.config.facets[e.id],l=s.facet(e);if(h&&!r&&w(n,h)){t.values[o]=l;return 0}let c=a(t);if(e.compare(c,l)){t.values[o]=l;return 0}t.values[o]=c;return 1}}}const T=Facet.define({static:true});class StateField{constructor(t,e,n,i,s){this.id=t;this.createF=e;this.updateF=n;this.compareF=i;this.spec=s;this.provides=void 0}static define(t){let e=new StateField(v++,t.create,t.update,t.compare||((t,e)=>t===e),t);t.provide&&(e.provides=t.provide(e));return e}create(t){let e=t.facet(T).find((t=>t.field==this));return((e===null||e===void 0?void 0:e.create)||this.createF)(t)}slot(t){let e=t[this.id]>>1;return{create:t=>{t.values[e]=this.create(t);return 1},update:(t,n)=>{let i=t.values[e];let s=this.updateF(i,n);if(this.compareF(i,s))return 0;t.values[e]=s;return 1},reconfigure:(t,n)=>{let i,s=t.facet(T),r=n.facet(T);if((i=s.find((t=>t.field==this)))&&i!=r.find((t=>t.field==this))){t.values[e]=i.create(t);return 1}if(n.config.address[this.id]!=null){t.values[e]=n.field(this);return 0}t.values[e]=this.create(t);return 1}}}init(t){return[this,T.of({field:this,create:t})]}get extension(){return this}}const C={lowest:4,low:3,default:2,high:1,highest:0};function I(t){return e=>new PrecExtension(e,t)}const R={highest:I(C.highest),high:I(C.high),default:I(C.default),low:I(C.low),lowest:I(C.lowest)};class PrecExtension{constructor(t,e){this.inner=t;this.prec=e}}class Compartment{of(t){return new CompartmentInstance(this,t)}reconfigure(t){return Compartment.reconfigure.of({compartment:this,extension:t})}get(t){return t.config.compartments.get(this)}}class CompartmentInstance{constructor(t,e){this.compartment=t;this.inner=e}}class Configuration{constructor(t,e,n,i,s,r){this.base=t;this.compartments=e;this.dynamicSlots=n;this.address=i;this.staticValues=s;this.facets=r;this.statusTemplate=[];while(this.statusTemplate.length<n.length)this.statusTemplate.push(0)}staticFacet(t){let e=this.address[t.id];return e==null?t.default:this.staticValues[e>>1]}static resolve(t,e,n){let i=[];let s=Object.create(null);let r=new Map;for(let n of P(t,e,r))n instanceof StateField?i.push(n):(s[n.facet.id]||(s[n.facet.id]=[])).push(n);let o=Object.create(null);let a=[];let h=[];for(let t of i){o[t.id]=h.length<<1;h.push((e=>t.slot(e)))}let l=n===null||n===void 0?void 0:n.config.facets;for(let t in s){let e=s[t],i=e[0].facet;let r=l&&l[t]||[];if(e.every((t=>t.type==0))){o[i.id]=a.length<<1|1;if(w(r,e))a.push(n.facet(i));else{let t=i.combine(e.map((t=>t.value)));a.push(n&&i.compare(t,n.facet(i))?n.facet(i):t)}}else{for(let t of e)if(t.type==0){o[t.id]=a.length<<1|1;a.push(t.value)}else{o[t.id]=h.length<<1;h.push((e=>t.dynamicSlot(e)))}o[i.id]=h.length<<1;h.push((t=>E(t,i,e)))}}let c=h.map((t=>t(o)));return new Configuration(t,r,c,o,a,s)}}function P(t,e,n){let i=[[],[],[],[],[]];let s=new Map;function r(t,o){let a=s.get(t);if(a!=null){if(a<=o)return;let e=i[a].indexOf(t);e>-1&&i[a].splice(e,1);t instanceof CompartmentInstance&&n.delete(t.compartment)}s.set(t,o);if(Array.isArray(t))for(let e of t)r(e,o);else if(t instanceof CompartmentInstance){if(n.has(t.compartment))throw new RangeError("Duplicate use of compartment in extensions");let i=e.get(t.compartment)||t.inner;n.set(t.compartment,i);r(i,o)}else if(t instanceof PrecExtension)r(t.inner,t.prec);else if(t instanceof StateField){i[o].push(t);t.provides&&r(t.provides,o)}else if(t instanceof FacetProvider){i[o].push(t);t.facet.extensions&&r(t.facet.extensions,C.default)}else{let e=t.extension;if(!e)throw new Error(`Unrecognized extension value in extension set (${t}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);r(e,o)}}r(t,C.default);return i.reduce(((t,e)=>t.concat(e)))}function b(t,e){if(e&1)return 2;let n=e>>1;let i=t.status[n];if(i==4)throw new Error("Cyclic dependency between fields and/or facets");if(i&2)return i;t.status[n]=4;let s=t.computeSlot(t,t.config.dynamicSlots[n]);return t.status[n]=2|s}function A(t,e){return e&1?t.config.staticValues[e>>1]:t.values[e>>1]}const M=Facet.define();const L=Facet.define({combine:t=>t.some((t=>t)),static:true});const F=Facet.define({combine:t=>t.length?t[0]:void 0,static:true});const O=Facet.define();const N=Facet.define();const D=Facet.define();const B=Facet.define({combine:t=>!!t.length&&t[0]});class Annotation{constructor(t,e){this.type=t;this.value=e}static define(){return new AnnotationType}}class AnnotationType{of(t){return new Annotation(this,t)}}class StateEffectType{constructor(t){this.map=t}of(t){return new StateEffect(this,t)}}class StateEffect{constructor(t,e){this.type=t;this.value=e}map(t){let e=this.type.map(this.value,t);return e===void 0?void 0:e==this.value?this:new StateEffect(this.type,e)}is(t){return this.type==t}static define(t={}){return new StateEffectType(t.map||(t=>t))}static mapEffects(t,e){if(!t.length)return t;let n=[];for(let i of t){let t=i.map(e);t&&n.push(t)}return n}}StateEffect.reconfigure=StateEffect.define();StateEffect.appendConfig=StateEffect.define();class Transaction{constructor(t,e,n,i,s,r){this.startState=t;this.changes=e;this.selection=n;this.effects=i;this.annotations=s;this.scrollIntoView=r;this._doc=null;this._state=null;n&&x(n,e.newLength);s.some((t=>t.type==Transaction.time))||(this.annotations=s.concat(Transaction.time.of(Date.now())))}static create(t,e,n,i,s,r){return new Transaction(t,e,n,i,s,r)}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){this._state||this.startState.applyTransaction(this);return this._state}annotation(t){for(let e of this.annotations)if(e.type==t)return e.value}get docChanged(){return!this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(t){let e=this.annotation(Transaction.userEvent);return!!(e&&(e==t||e.length>t.length&&e.slice(0,t.length)==t&&e[t.length]=="."))}}Transaction.time=Annotation.define();Transaction.userEvent=Annotation.define();Transaction.addToHistory=Annotation.define();Transaction.remote=Annotation.define();function J(t,e){let n=[];for(let i=0,s=0;;){let r,o;if(i<t.length&&(s==e.length||e[s]>=t[i])){r=t[i++];o=t[i++]}else{if(!(s<e.length))return n;r=e[s++];o=e[s++]}!n.length||n[n.length-1]<r?n.push(r,o):n[n.length-1]<o&&(n[n.length-1]=o)}}function V(t,e,n){var i;let s,r,o;if(n){s=e.changes;r=ChangeSet.empty(e.changes.length);o=t.changes.compose(e.changes)}else{s=e.changes.map(t.changes);r=t.changes.mapDesc(e.changes,true);o=t.changes.compose(s)}return{changes:o,selection:e.selection?e.selection.map(r):(i=t.selection)===null||i===void 0?void 0:i.map(s),effects:StateEffect.mapEffects(t.effects,s).concat(StateEffect.mapEffects(e.effects,r)),annotations:t.annotations.length?t.annotations.concat(e.annotations):e.annotations,scrollIntoView:t.scrollIntoView||e.scrollIntoView}}function $(t,e,n){let i=e.selection,s=H(e.annotations);e.userEvent&&(s=s.concat(Transaction.userEvent.of(e.userEvent)));return{changes:e.changes instanceof ChangeSet?e.changes:ChangeSet.of(e.changes||[],n,t.facet(F)),selection:i&&(i instanceof EditorSelection?i:EditorSelection.single(i.anchor,i.head)),effects:H(e.effects),annotations:s,scrollIntoView:!!e.scrollIntoView}}function j(t,e,n){let i=$(t,e.length?e[0]:{},t.doc.length);e.length&&e[0].filter===false&&(n=false);for(let s=1;s<e.length;s++){e[s].filter===false&&(n=false);let r=!!e[s].sequential;i=V(i,$(t,e[s],r?i.changes.newLength:t.doc.length),r)}let s=Transaction.create(t,i.changes,i.selection,i.effects,i.annotations,i.scrollIntoView);return q(n?z(s):s)}function z(t){let e=t.startState;let n=true;for(let i of e.facet(O)){let e=i(t);if(e===false){n=false;break}Array.isArray(e)&&(n=n===true?e:J(n,e))}if(n!==true){let i,s;if(n===false){s=t.changes.invertedDesc;i=ChangeSet.empty(e.doc.length)}else{let e=t.changes.filter(n);i=e.changes;s=e.filtered.mapDesc(e.changes).invertedDesc}t=Transaction.create(e,i,t.selection&&t.selection.map(s),StateEffect.mapEffects(t.effects,s),t.annotations,t.scrollIntoView)}let i=e.facet(N);for(let n=i.length-1;n>=0;n--){let s=i[n](t);t=s instanceof Transaction?s:Array.isArray(s)&&s.length==1&&s[0]instanceof Transaction?s[0]:j(e,H(s),false)}return t}function q(t){let e=t.startState,n=e.facet(D),i=t;for(let s=n.length-1;s>=0;s--){let r=n[s](t);r&&Object.keys(r).length&&(i=V(i,$(e,r,t.changes.newLength),true))}return i==t?t:Transaction.create(e,t.changes,t.selection,i.effects,i.annotations,i.scrollIntoView)}const _=[];function H(t){return t==null?_:Array.isArray(t)?t:[t]}var W=function(t){t[t.Word=0]="Word";t[t.Space=1]="Space";t[t.Other=2]="Other";return t}(W||(W={}));const U=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;let G;try{G=new RegExp("[\\p{Alphabetic}\\p{Number}_]","u")}catch(t){}function K(t){if(G)return G.test(t);for(let e=0;e<t.length;e++){let n=t[e];if(/\w/.test(n)||n>"Â€"&&(n.toUpperCase()!=n.toLowerCase()||U.test(n)))return true}return false}function Q(t){return e=>{if(!/\S/.test(e))return W.Space;if(K(e))return W.Word;for(let n=0;n<t.length;n++)if(e.indexOf(t[n])>-1)return W.Word;return W.Other}}class EditorState{constructor(t,e,n,i,s,r){this.config=t;this.doc=e;this.selection=n;this.values=i;this.status=t.statusTemplate.slice();this.computeSlot=s;r&&(r._state=this);for(let t=0;t<this.config.dynamicSlots.length;t++)b(this,t<<1);this.computeSlot=null}field(t,e=true){let n=this.config.address[t.id];if(n!=null){b(this,n);return A(this,n)}if(e)throw new RangeError("Field is not present in this state")}update(...t){return j(this,t,true)}applyTransaction(t){let e=this.config,{base:n,compartments:i}=e;for(let s of t.effects)if(s.is(Compartment.reconfigure)){if(e){i=new Map;e.compartments.forEach(((t,e)=>i.set(e,t)));e=null}i.set(s.value.compartment,s.value.extension)}else if(s.is(StateEffect.reconfigure)){e=null;n=s.value}else if(s.is(StateEffect.appendConfig)){e=null;n=H(n).concat(s.value)}let s;if(e)s=t.startState.values.slice();else{e=Configuration.resolve(n,i,this);let t=new EditorState(e,this.doc,this.selection,e.dynamicSlots.map((()=>null)),((t,e)=>e.reconfigure(t,this)),null);s=t.values}let r=t.startState.facet(L)?t.newSelection:t.newSelection.asSingle();new EditorState(e,t.newDoc,r,s,((e,n)=>n.update(e,t)),t)}replaceSelection(t){typeof t=="string"&&(t=this.toText(t));return this.changeByRange((e=>({changes:{from:e.from,to:e.to,insert:t},range:EditorSelection.cursor(e.from+t.length)})))}changeByRange(t){let e=this.selection;let n=t(e.ranges[0]);let i=this.changes(n.changes),s=[n.range];let r=H(n.effects);for(let n=1;n<e.ranges.length;n++){let o=t(e.ranges[n]);let a=this.changes(o.changes),h=a.map(i);for(let t=0;t<n;t++)s[t]=s[t].map(h);let l=i.mapDesc(a,true);s.push(o.range.map(l));i=i.compose(h);r=StateEffect.mapEffects(r,h).concat(StateEffect.mapEffects(H(o.effects),l))}return{changes:i,selection:EditorSelection.create(s,e.mainIndex),effects:r}}changes(t=[]){return t instanceof ChangeSet?t:ChangeSet.of(t,this.doc.length,this.facet(EditorState.lineSeparator))}toText(t){return Text.of(t.split(this.facet(EditorState.lineSeparator)||f))}sliceDoc(t=0,e=this.doc.length){return this.doc.sliceString(t,e,this.lineBreak)}facet(t){let e=this.config.address[t.id];if(e==null)return t.default;b(this,e);return A(this,e)}toJSON(t){let e={doc:this.sliceDoc(),selection:this.selection.toJSON()};if(t)for(let n in t){let i=t[n];i instanceof StateField&&this.config.address[i.id]!=null&&(e[n]=i.spec.toJSON(this.field(t[n]),this))}return e}static fromJSON(t,e={},n){if(!t||typeof t.doc!="string")throw new RangeError("Invalid JSON representation for EditorState");let i=[];if(n)for(let e in n)if(Object.prototype.hasOwnProperty.call(t,e)){let s=n[e],r=t[e];i.push(s.init((t=>s.spec.fromJSON(r,t))))}return EditorState.create({doc:t.doc,selection:EditorSelection.fromJSON(t.selection),extensions:e.extensions?i.concat([e.extensions]):i})}static create(t={}){let e=Configuration.resolve(t.extensions||[],new Map);let n=t.doc instanceof Text?t.doc:Text.of((t.doc||"").split(e.staticFacet(EditorState.lineSeparator)||f));let i=t.selection?t.selection instanceof EditorSelection?t.selection:EditorSelection.single(t.selection.anchor,t.selection.head):EditorSelection.single(0);x(i,n.length);e.staticFacet(L)||(i=i.asSingle());return new EditorState(e,n,i,e.dynamicSlots.map((()=>null)),((t,e)=>e.create(t)),null)}get tabSize(){return this.facet(EditorState.tabSize)}get lineBreak(){return this.facet(EditorState.lineSeparator)||"\n"}get readOnly(){return this.facet(B)}phrase(t,...e){for(let e of this.facet(EditorState.phrases))if(Object.prototype.hasOwnProperty.call(e,t)){t=e[t];break}e.length&&(t=t.replace(/\$(\$|\d*)/g,((t,n)=>{if(n=="$")return"$";let i=+(n||1);return!i||i>e.length?t:e[i-1]})));return t}languageDataAt(t,e,n=-1){let i=[];for(let s of this.facet(M))for(let r of s(this,e,n))Object.prototype.hasOwnProperty.call(r,t)&&i.push(r[t]);return i}charCategorizer(t){let e=this.languageDataAt("wordChars",t);return Q(e.length?e[0]:"")}wordAt(t){let{text:e,from:n,length:i}=this.doc.lineAt(t);let s=this.charCategorizer(t);let o=t-n,a=t-n;while(o>0){let t=r(e,o,false);if(s(e.slice(t,o))!=W.Word)break;o=t}while(a<i){let t=r(e,a);if(s(e.slice(a,t))!=W.Word)break;a=t}return o==a?null:EditorSelection.range(o+n,a+n)}}EditorState.allowMultipleSelections=L;EditorState.tabSize=Facet.define({combine:t=>t.length?t[0]:4});EditorState.lineSeparator=F;EditorState.readOnly=B;EditorState.phrases=Facet.define({compare(t,e){let n=Object.keys(t),i=Object.keys(e);return n.length==i.length&&n.every((n=>t[n]==e[n]))}});EditorState.languageData=M;EditorState.changeFilter=O;EditorState.transactionFilter=N;EditorState.transactionExtender=D;Compartment.reconfigure=StateEffect.define();function X(t,e,n={}){let i={};for(let e of t)for(let t of Object.keys(e)){let s=e[t],r=i[t];if(r===void 0)i[t]=s;else if(r===s||s===void 0);else{if(!Object.hasOwnProperty.call(n,t))throw new Error("Config merge conflict for field "+t);i[t]=n[t](r,s)}}for(let t in e)i[t]===void 0&&(i[t]=e[t]);return i}class RangeValue{eq(t){return this==t}range(t,e=t){return Range.create(t,e,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0;RangeValue.prototype.point=false;RangeValue.prototype.mapMode=u.TrackDel;function Y(t,e){return t==e||t.constructor==e.constructor&&t.eq(e)}class Range{constructor(t,e,n){this.from=t;this.to=e;this.value=n}static create(t,e,n){return new Range(t,e,n)}}function Z(t,e){return t.from-e.from||t.value.startSide-e.value.startSide}class Chunk{constructor(t,e,n,i){this.from=t;this.to=e;this.value=n;this.maxPoint=i}get length(){return this.to[this.to.length-1]}findIndex(t,e,n,i=0){let s=n?this.to:this.from;for(let r=i,o=s.length;;){if(r==o)return r;let i=r+o>>1;let a=s[i]-t||(n?this.value[i].endSide:this.value[i].startSide)-e;if(i==r)return a>=0?r:o;a>=0?o=i:r=i+1}}between(t,e,n,i){for(let s=this.findIndex(e,-1e9,true),r=this.findIndex(n,1e9,false,s);s<r;s++)if(i(this.from[s]+t,this.to[s]+t,this.value[s])===false)return false}map(t,e){let n=[],i=[],s=[],r=-1,o=-1;for(let a=0;a<this.value.length;a++){let h,l,c=this.value[a],f=this.from[a]+t,u=this.to[a]+t;if(f==u){let t=e.mapPos(f,c.startSide,c.mapMode);if(t==null)continue;h=l=t;if(c.startSide!=c.endSide){l=e.mapPos(f,c.endSide);if(l<h)continue}}else{h=e.mapPos(f,c.startSide);l=e.mapPos(u,c.endSide);if(h>l||h==l&&c.startSide>0&&c.endSide<=0)continue}if(!((l-h||c.endSide-c.startSide)<0)){r<0&&(r=h);c.point&&(o=Math.max(o,l-h));n.push(c);i.push(h-r);s.push(l-r)}}return{mapped:n.length?new Chunk(i,s,n,o):null,pos:r}}}class RangeSet{constructor(t,e,n,i){this.chunkPos=t;this.chunk=e;this.nextLayer=n;this.maxPoint=i}static create(t,e,n,i){return new RangeSet(t,e,n,i)}get length(){let t=this.chunk.length-1;return t<0?0:Math.max(this.chunkEnd(t),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let t=this.nextLayer.size;for(let e of this.chunk)t+=e.value.length;return t}chunkEnd(t){return this.chunkPos[t]+this.chunk[t].length}update(t){let{add:e=[],sort:n=false,filterFrom:i=0,filterTo:s=this.length}=t;let r=t.filter;if(e.length==0&&!r)return this;n&&(e=e.slice().sort(Z));if(this.isEmpty)return e.length?RangeSet.of(e):this;let o=new LayerCursor(this,null,-1).goto(0),a=0,h=[];let l=new RangeSetBuilder;while(o.value||a<e.length)if(a<e.length&&(o.from-e[a].from||o.startSide-e[a].value.startSide)>=0){let t=e[a++];l.addInner(t.from,t.to,t.value)||h.push(t)}else if(o.rangeIndex==1&&o.chunkIndex<this.chunk.length&&(a==e.length||this.chunkEnd(o.chunkIndex)<e[a].from)&&(!r||i>this.chunkEnd(o.chunkIndex)||s<this.chunkPos[o.chunkIndex])&&l.addChunk(this.chunkPos[o.chunkIndex],this.chunk[o.chunkIndex]))o.nextChunk();else{(!r||i>o.to||s<o.from||r(o.from,o.to,o.value))&&(l.addInner(o.from,o.to,o.value)||h.push(Range.create(o.from,o.to,o.value)));o.next()}return l.finishInner(this.nextLayer.isEmpty&&!h.length?RangeSet.empty:this.nextLayer.update({add:h,filter:r,filterFrom:i,filterTo:s}))}map(t){if(t.empty||this.isEmpty)return this;let e=[],n=[],i=-1;for(let s=0;s<this.chunk.length;s++){let r=this.chunkPos[s],o=this.chunk[s];let a=t.touchesRange(r,r+o.length);if(a===false){i=Math.max(i,o.maxPoint);e.push(o);n.push(t.mapPos(r))}else if(a===true){let{mapped:s,pos:a}=o.map(r,t);if(s){i=Math.max(i,s.maxPoint);e.push(s);n.push(a)}}}let s=this.nextLayer.map(t);return e.length==0?s:new RangeSet(n,e,s||RangeSet.empty,i)}between(t,e,n){if(!this.isEmpty){for(let i=0;i<this.chunk.length;i++){let s=this.chunkPos[i],r=this.chunk[i];if(e>=s&&t<=s+r.length&&r.between(s,t-s,e-s,n)===false)return}this.nextLayer.between(t,e,n)}}iter(t=0){return HeapCursor.from([this]).goto(t)}get isEmpty(){return this.nextLayer==this}static iter(t,e=0){return HeapCursor.from(t).goto(e)}static compare(t,e,n,i,s=-1){let r=t.filter((t=>t.maxPoint>0||!t.isEmpty&&t.maxPoint>=s));let o=e.filter((t=>t.maxPoint>0||!t.isEmpty&&t.maxPoint>=s));let a=et(r,o,n);let h=new SpanCursor(r,a,s);let l=new SpanCursor(o,a,s);n.iterGaps(((t,e,n)=>it(h,t,l,e,n,i)));n.empty&&n.length==0&&it(h,0,l,0,0,i)}static eq(t,e,n=0,i){i==null&&(i=999999999);let s=t.filter((t=>!t.isEmpty&&e.indexOf(t)<0));let r=e.filter((e=>!e.isEmpty&&t.indexOf(e)<0));if(s.length!=r.length)return false;if(!s.length)return true;let o=et(s,r);let a=new SpanCursor(s,o,0).goto(n),h=new SpanCursor(r,o,0).goto(n);for(;;){if(a.to!=h.to||!st(a.active,h.active)||a.point&&(!h.point||!Y(a.point,h.point)))return false;if(a.to>i)return true;a.next();h.next()}}static spans(t,e,n,i,s=-1){let r=new SpanCursor(t,null,s).goto(e),o=e;let a=r.openStart;for(;;){let t=Math.min(r.to,n);if(r.point){let n=r.activeForPoint(r.to);let s=r.pointFrom<e?n.length+1:r.point.startSide<0?n.length:Math.min(n.length,a);i.point(o,t,r.point,n,s,r.pointRank);a=Math.min(r.openEnd(t),n.length)}else if(t>o){i.span(o,t,r.active,a);a=r.openEnd(t)}if(r.to>n)return a+(r.point&&r.to>n?1:0);o=r.to;r.next()}}static of(t,e=false){let n=new RangeSetBuilder;for(let i of t instanceof Range?[t]:e?tt(t):t)n.add(i.from,i.to,i.value);return n.finish()}static join(t){if(!t.length)return RangeSet.empty;let e=t[t.length-1];for(let n=t.length-2;n>=0;n--)for(let i=t[n];i!=RangeSet.empty;i=i.nextLayer)e=new RangeSet(i.chunkPos,i.chunk,e,Math.max(i.maxPoint,e.maxPoint));return e}}RangeSet.empty=new RangeSet([],[],null,-1);function tt(t){if(t.length>1)for(let e=t[0],n=1;n<t.length;n++){let i=t[n];if(Z(e,i)>0)return t.slice().sort(Z);e=i}return t}RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{finishChunk(t){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint));this.chunkPos.push(this.chunkStart);this.chunkStart=-1;this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint);this.maxPoint=-1;if(t){this.from=[];this.to=[];this.value=[]}}constructor(){this.chunks=[];this.chunkPos=[];this.chunkStart=-1;this.last=null;this.lastFrom=-1e9;this.lastTo=-1e9;this.from=[];this.to=[];this.value=[];this.maxPoint=-1;this.setMaxPoint=-1;this.nextLayer=null}add(t,e,n){this.addInner(t,e,n)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(t,e,n)}addInner(t,e,n){let i=t-this.lastTo||n.startSide-this.last.endSide;if(i<=0&&(t-this.lastFrom||n.startSide-this.last.startSide)<0)throw new Error("Ranges must be added sorted by `from` position and `startSide`");if(i<0)return false;this.from.length==250&&this.finishChunk(true);this.chunkStart<0&&(this.chunkStart=t);this.from.push(t-this.chunkStart);this.to.push(e-this.chunkStart);this.last=n;this.lastFrom=t;this.lastTo=e;this.value.push(n);n.point&&(this.maxPoint=Math.max(this.maxPoint,e-t));return true}addChunk(t,e){if((t-this.lastTo||e.value[0].startSide-this.last.endSide)<0)return false;this.from.length&&this.finishChunk(true);this.setMaxPoint=Math.max(this.setMaxPoint,e.maxPoint);this.chunks.push(e);this.chunkPos.push(t);let n=e.value.length-1;this.last=e.value[n];this.lastFrom=e.from[n]+t;this.lastTo=e.to[n]+t;return true}finish(){return this.finishInner(RangeSet.empty)}finishInner(t){this.from.length&&this.finishChunk(false);if(this.chunks.length==0)return t;let e=RangeSet.create(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(t):t,this.setMaxPoint);this.from=null;return e}}function et(t,e,n){let i=new Map;for(let e of t)for(let t=0;t<e.chunk.length;t++)e.chunk[t].maxPoint<=0&&i.set(e.chunk[t],e.chunkPos[t]);let s=new Set;for(let t of e)for(let e=0;e<t.chunk.length;e++){let r=i.get(t.chunk[e]);r==null||(n?n.mapPos(r):r)!=t.chunkPos[e]||(n===null||n===void 0?void 0:n.touchesRange(r,r+t.chunk[e].length))||s.add(t.chunk[e])}return s}class LayerCursor{constructor(t,e,n,i=0){this.layer=t;this.skip=e;this.minPoint=n;this.rank=i}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(t,e=-1e9){this.chunkIndex=this.rangeIndex=0;this.gotoInner(t,e,false);return this}gotoInner(t,e,n){while(this.chunkIndex<this.layer.chunk.length){let e=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(e)||this.layer.chunkEnd(this.chunkIndex)<t||e.maxPoint<this.minPoint))break;this.chunkIndex++;n=false}if(this.chunkIndex<this.layer.chunk.length){let i=this.layer.chunk[this.chunkIndex].findIndex(t-this.layer.chunkPos[this.chunkIndex],e,true);(!n||this.rangeIndex<i)&&this.setRangeIndex(i)}this.next()}forward(t,e){(this.to-t||this.endSide-e)<0&&this.gotoInner(t,e,true)}next(){for(;;){if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9;this.value=null;break}{let t=this.layer.chunkPos[this.chunkIndex],e=this.layer.chunk[this.chunkIndex];let n=t+e.from[this.rangeIndex];this.from=n;this.to=t+e.to[this.rangeIndex];this.value=e.value[this.rangeIndex];this.setRangeIndex(this.rangeIndex+1);if(this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}}setRangeIndex(t){if(t==this.layer.chunk[this.chunkIndex].value.length){this.chunkIndex++;if(this.skip)while(this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=t}nextChunk(){this.chunkIndex++;this.rangeIndex=0;this.next()}compare(t){return this.from-t.from||this.startSide-t.startSide||this.rank-t.rank||this.to-t.to||this.endSide-t.endSide}}class HeapCursor{constructor(t){this.heap=t}static from(t,e=null,n=-1){let i=[];for(let s=0;s<t.length;s++)for(let r=t[s];!r.isEmpty;r=r.nextLayer)r.maxPoint>=n&&i.push(new LayerCursor(r,e,n,s));return i.length==1?i[0]:new HeapCursor(i)}get startSide(){return this.value?this.value.startSide:0}goto(t,e=-1e9){for(let n of this.heap)n.goto(t,e);for(let t=this.heap.length>>1;t>=0;t--)nt(this.heap,t);this.next();return this}forward(t,e){for(let n of this.heap)n.forward(t,e);for(let t=this.heap.length>>1;t>=0;t--)nt(this.heap,t);(this.to-t||this.value.endSide-e)<0&&this.next()}next(){if(this.heap.length==0){this.from=this.to=1e9;this.value=null;this.rank=-1}else{let t=this.heap[0];this.from=t.from;this.to=t.to;this.value=t.value;this.rank=t.rank;t.value&&t.next();nt(this.heap,0)}}}function nt(t,e){for(let n=t[e];;){let i=1+(e<<1);if(i>=t.length)break;let s=t[i];if(i+1<t.length&&s.compare(t[i+1])>=0){s=t[i+1];i++}if(n.compare(s)<0)break;t[i]=n;t[e]=s;e=i}}class SpanCursor{constructor(t,e,n){this.minPoint=n;this.active=[];this.activeTo=[];this.activeRank=[];this.minActive=-1;this.point=null;this.pointFrom=0;this.pointRank=0;this.to=-1e9;this.endSide=0;this.openStart=-1;this.cursor=HeapCursor.from(t,e,n)}goto(t,e=-1e9){this.cursor.goto(t,e);this.active.length=this.activeTo.length=this.activeRank.length=0;this.minActive=-1;this.to=t;this.endSide=e;this.openStart=-1;this.next();return this}forward(t,e){while(this.minActive>-1&&(this.activeTo[this.minActive]-t||this.active[this.minActive].endSide-e)<0)this.removeActive(this.minActive);this.cursor.forward(t,e)}removeActive(t){rt(this.active,t);rt(this.activeTo,t);rt(this.activeRank,t);this.minActive=at(this.active,this.activeTo)}addActive(t){let e=0,{value:n,to:i,rank:s}=this.cursor;while(e<this.activeRank.length&&(s-this.activeRank[e]||i-this.activeTo[e])>0)e++;ot(this.active,e,n);ot(this.activeTo,e,i);ot(this.activeRank,e,s);t&&ot(t,e,this.cursor.from);this.minActive=at(this.active,this.activeTo)}next(){let t=this.to,e=this.point;this.point=null;let n=this.openStart<0?[]:null;for(;;){let i=this.minActive;if(i>-1&&(this.activeTo[i]-this.cursor.from||this.active[i].endSide-this.cursor.startSide)<0){if(this.activeTo[i]>t){this.to=this.activeTo[i];this.endSide=this.active[i].endSide;break}this.removeActive(i);n&&rt(n,i)}else{if(!this.cursor.value){this.to=this.endSide=1e9;break}if(this.cursor.from>t){this.to=this.cursor.from;this.endSide=this.cursor.startSide;break}{let t=this.cursor.value;if(t.point){if(!(e&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)){this.point=t;this.pointFrom=this.cursor.from;this.pointRank=this.cursor.rank;this.to=this.cursor.to;this.endSide=t.endSide;this.cursor.next();this.forward(this.to,this.endSide);break}this.cursor.next()}else{this.addActive(n);this.cursor.next()}}}}if(n){this.openStart=0;for(let e=n.length-1;e>=0&&n[e]<t;e--)this.openStart++}}activeForPoint(t){if(!this.active.length)return this.active;let e=[];for(let n=this.active.length-1;n>=0;n--){if(this.activeRank[n]<this.pointRank)break;(this.activeTo[n]>t||this.activeTo[n]==t&&this.active[n].endSide>=this.point.endSide)&&e.push(this.active[n])}return e.reverse()}openEnd(t){let e=0;for(let n=this.activeTo.length-1;n>=0&&this.activeTo[n]>t;n--)e++;return e}}function it(t,e,n,i,s,r){t.goto(e);n.goto(i);let o=i+s;let a=i,h=i-e;let l=!!r.boundChange;for(let e=false;;){let i=t.to+h-n.to,s=i||t.endSide-n.endSide;let c=s<0?t.to+h:n.to,f=Math.min(c,o);let u=t.point||n.point;if(u){t.point&&n.point&&Y(t.point,n.point)&&st(t.activeForPoint(t.to),n.activeForPoint(n.to))||r.comparePoint(a,f,t.point,n.point);e=false}else{e&&r.boundChange(a);f>a&&!st(t.active,n.active)&&r.compareRange(a,f,t.active,n.active);l&&f<o&&(i||t.openEnd(c)!=n.openEnd(c))&&(e=true)}if(c>o)break;a=c;s<=0&&t.next();s>=0&&n.next()}}function st(t,e){if(t.length!=e.length)return false;for(let n=0;n<t.length;n++)if(t[n]!=e[n]&&!Y(t[n],e[n]))return false;return true}function rt(t,e){for(let n=e,i=t.length-1;n<i;n++)t[n]=t[n+1];t.pop()}function ot(t,e,n){for(let n=t.length-1;n>=e;n--)t[n+1]=t[n];t[e]=n}function at(t,e){let n=-1,i=1e9;for(let s=0;s<e.length;s++)if((e[s]-i||t[s].endSide-t[n].endSide)<0){n=s;i=e[s]}return n}function ht(t,e,n=t.length){let i=0;for(let s=0;s<n&&s<t.length;)if(t.charCodeAt(s)==9){i+=e-i%e;s++}else{i++;s=r(t,s)}return i}function lt(t,e,n,i){for(let i=0,s=0;;){if(s>=e)return i;if(i==t.length)break;s+=t.charCodeAt(i)==9?n-s%n:1;i=r(t,i)}return i===true?-1:t.length}export{Annotation,AnnotationType,ChangeDesc,ChangeSet,W as CharCategory,Compartment,EditorSelection,EditorState,Facet,Line,u as MapMode,R as Prec,Range,RangeSet,RangeSetBuilder,RangeValue,SelectionRange,StateEffect,StateEffectType,StateField,Text,Transaction,h as codePointAt,c as codePointSize,X as combineConfig,ht as countColumn,r as findClusterBreak,lt as findColumn,l as fromCodePoint};

